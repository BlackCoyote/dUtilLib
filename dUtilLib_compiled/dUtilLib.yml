DUL_colorcode_message:
  type: procedure
  debug: false
  DUL:
    author:
    - BlackCoyote
    description:
    - Encodes your message into a colour code string and back.
    -  only works with characters from a-z, 0-9, and _ !
    usage:
    - <proc[DUL_colorcode_message].context[encode/decode|<message>]>
    example:
    - <proc[DUL_colorcode_message].context[encode|my_sword_id]>
  encode:
    a: '&0&0'
    b: '&0&1'
    c: '&0&2'
    d: '&0&3'
    e: '&0&4'
    f: '&0&5'
    g: '&0&6'
    h: '&0&7'
    i: '&0&8'
    j: '&0&9'
    k: '&1&0'
    l: '&1&1'
    m: '&1&2'
    n: '&1&3'
    o: '&1&4'
    p: '&1&5'
    q: '&1&6'
    r: '&1&7'
    s: '&1&8'
    t: '&1&9'
    u: '&2&0'
    v: '&2&1'
    w: '&2&2'
    x: '&2&3'
    y: '&2&4'
    z: '&2&5'
    0: '&2&6'
    1: '&2&7'
    2: '&2&8'
    3: '&2&9'
    4: '&3&0'
    5: '&3&1'
    6: '&3&2'
    7: '&3&3'
    8: '&3&4'
    9: '&3&5'
    _: '&3&6'
  decode:
    '&0&0': a
    '&0&1': b
    '&0&2': c
    '&0&3': d
    '&0&4': e
    '&0&5': f
    '&0&6': g
    '&0&7': h
    '&0&8': i
    '&0&9': j
    '&1&0': k
    '&1&1': l
    '&1&2': m
    '&1&3': n
    '&1&4': o
    '&1&5': p
    '&1&6': q
    '&1&7': r
    '&1&8': s
    '&1&9': t
    '&2&0': u
    '&2&1': v
    '&2&2': w
    '&2&3': x
    '&2&4': y
    '&2&5': z
    '&2&6': 0
    '&2&7': 1
    '&2&8': 2
    '&2&9': 3
    '&3&0': 4
    '&3&1': 5
    '&3&2': 6
    '&3&3': 7
    '&3&4': 8
    '&3&5': 9
    '&3&6': _
  script:
  - if li@encode|decode !contains <def[1]||> {
    - debug error "DUL - No valid action specified! Must be encode or decode!"
    - determine null
    }
  - if <def[2]||> == "" {
    - debug error "DUL - No message specified to <def[1]>!"
    - determine null
    }
  - define result ""
  - if <def[1]> == encode {
    - define list <def[2].to_list>
    } else {
    - define list li@
    - define 2 <def[2].escaped.replace[&ss].with[&]>
    - repeat <def[2].length.div[4].as_int> {
      - define list <def[list].include[<def[2].substring[<def[value].mul[4].sub[4].add[1]||1>,<def[value].mul[4]>]>]>
      }
    }
  - foreach <def[list]>:
    - define result "<def[result]><script.yaml_key[<def[1]>.<def[value]>]||->"
  - determine <def[result].parse_color>
DUL_hidden_spawn_locations:
  type: procedure
  debug: false
  definitions: location|radius
  DUL:
    author:
    - BlackCoyote
    description:
    - Finds spawn locations within range that are out of line of sight.
    - If no locations out of line of sight are found, it will return valid spawn locations within line of sight.
    usage:
    - <proc[DUL_hidden_spawn_locations].context[<l@location>|<radius>]>
    example:
    - <proc[DUL_hidden_spawn_locations].context[<player.location>|15]>
  script:
  - if <def[location]||null> !matches location {
    - debug error "DUL - No valid location specified!"
    - determine null
    }
  - if <def[radius]||null> !matches number {
    - debug error "DUL - No valid radius specified!"
    - determine null
    }
  - define radius <def[radius].as_int>
  - determine <def[location].find.surface_blocks.within[<def[radius]>].filter[y.sub[<def[location].y>].abs.is[less].than[3]].filter[above.above.above.material.name.is[==].to[air]].filter[above.above.above.above.material.name.is[==].to[air]].filter[above.above.above.above.above.material.name.is[==].to[air]].filter[material.is_occluding].parse[above].filter[above.center.line_of_sight[<def[location].add[0,1.5,0].center>].not]||<def[location].find.surface_blocks.within[<def[radius]>]||li@<def[location]>>>
DUL_rainbow_text:
  type: procedure
  debug: false
  DUL:
    author:
    - BlackCoyote
    description:
    - Turns the colour of a text into a rainbow format with a new colour per letter.
    usage:
    - <proc[DUL_rainbow_text].context[<text>]>
    example:
    - <proc[DUL_rainbow_text].context[I am pretty!]>
  script:
  - if <def[1].exists.not> {
    - debug error "DUL - No valid text specified!"
    - determine null
    }
  - define colormap li@&4|&6|&e|&a|&3|&9|&5
  - define result ""
  - foreach <def[1].to_list>:
    - define result "<def[result]><def[colormap].get[<def[loop_index].sub[1].mod[7].add[1].as_int>]><def[value]>"
  - determine <def[result].parse_color>
DUL_random_surface_block:
  type: procedure
  definitions: location|radius
  debug: false
  DUL:
    author:
    - BlackCoyote
    description:
    - Finds a random surface block within the provided radius more efficiently than conventional denizen tags.
    usage:
    - <proc[DUL_random_surface_block].context[<l@location>|<radius>]>
    example:
    - <proc[DUL_random_surface_block].context[<player.location>|5000]>
  script:
  - if <def[location]||null> !matches location {
    - debug error "DUL - No valid location specified!"
    - determine null
    }
  - if <def[radius]||null> !matches number {
    - debug error "DUL - No valid radius specified!"
    - determine null
    }
  - while true:
    - define newloc <def[location].add[<util.random.int[<def[radius].mul[-1]>].to[<def[radius]>]>,0,<util.random.int[<def[radius].mul[-1]>].to[<def[radius]>]>].highest.find.surface_blocks.within[5].get[1]||null>
    - if <def[newloc]> != null && <def[newloc].material.is_occluding> {
      - determine <def[newloc].above>
      } else if <def[loop_index]> >= 10 {
      - determine null
      }
DUL_script_tracker:
  type: world
  debug: false
  events:
    on system time hourly:
    - webget "http://morphanone.space/webizen.aspx/tracker?script=96&version=<s@DUL_version_script.yaml_key[version]>"
DUL_text_progress_bar:
  type: procedure
  debug: false
  DUL:
    author:
    - BlackCoyote
    description:
    - Makes a text based progress bar based on the percentage you provide.
    usage:
    - <proc[DUL_text_progress_bar].context[<percentage>(|<size>|<character>|<color1>|<color2>)]>
    example:
    - <proc[DUL_text_progress_bar].context[<player.health.percentage>]>
  script:
  - define percentage <def[1]||0>
  - if <def[percentage].as_int||none> == none {
    - define percentage 0
    }
  - if <def[2].exists> {
    - define max <def[2]>
    }
  - if <def[max].as_int||none> == none {
    - define max 10
    }
  - if <def[3].exists> {
    - define char <def[3].substring[1,1]||=>
    } else {
    - define char =
    }
  - if <def[4].exists> {
    - define col1 <def[4]>
    } else {
    - define col1 &a
    }
  - if <def[5].exists> {
    - define col2 <def[5]>
    } else {
    - define col2 &7
    }
  - define string <el@.pad_right[<def[max]>].with[<def[char]>]>
  - define split <def[max].div[100].mul[<def[percentage]>].as_int>
  - determine "<def[col1].parse_colors><def[string].substring[1,<def[split]>]><def[col2].parse_colors><def[string].substring[<def[split].add[1].as_int>,<def[max]>]>"
DUL_unique_queue_id_prefixed:
  type: procedure
  debug: false
  DUL:
    author:
    - BlackCoyote
    description:
    - Gives a unique queue ID for you to use, with a specified prefix.
    usage:
    - <proc[DUL_unique_queue_id_prefixed].context[<prefix>]>
    example:
    - <proc[DUL_unique_queue_id_prefixed].context[DUL_<player>]>
  script:
  - define prefix <def[1]||>
  - define id <def[prefix]><util.random.duuid>
  - while <queue.list.parse[id].contains[<def[id]>]>:
    - define id <def[prefix]><util.random.duuid>
  - determine <def[id]>
DUL_version_script:
  type: version
  name: dUtilLib
  id: 96
  description: A collection of dscript functions and utilities written by BlackCoyote and Anthony.
  version: 5
DUL_WRCG:
  type: procedure
  debug: false
  DUL:
    author:
    - Anthony
    name:
    - Weighted Random Choice Generator
    description:
    - Supply a list of weight/return values and have one of the values returned to you randomly based on weight.
    usage:
    - <proc[DUL_WRCG].context[weight/return|...]>
    example:
    - give <proc[DUL_WRCG].context[10/i@apple|1/i@gold_ingot|20/i@stone]>
  script:
    - define l 'li@'
    - foreach '<queue.definitions.exclude[l]>':
      - define l '<def[l].include[<def[%value%]>]>'
    - define w '0'
    - foreach '<def[l].parse[before[/]]>':
      - define w '<def[w].add[%value%]>'
    - define number '<util.random.int[1].to[%w%]>'
    - define hv '0'
    - foreach '%l%':
      - define ov '%hv%'
      - define lv '<def[ov].add[1]>'
      - define hv '<def[ov].add[<def[value].before[/]>]>'
      - if %number% >= %lv% && %number% <= %hv% {
        - determine '<def[value].after[/]>'
        }
