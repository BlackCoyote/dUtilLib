DUL_random_numbers_by_total:
  type: procedure
  debug: false
  DUL:
    name:
    - Random Numbers by Total
    author:
    - BlackCoyote
    description:
    - returns the specified amount of random positive integer numbers that always add up to the specified total.
    usage:
    - <proc[DUL_random_numbers_by_total].context[<amount>|<total>]>
    example:
    - <proc[DUL_random_numbers_by_total].context[5|100]>
  definitions: amount|total
  script:
    - if <def[amount]||null> !matches number {
      - debug error "DUL - No valid amount specified."
      - determine null
      }
    - if <def[total]||null> !matches number {
      - debug error "DUL - No valid total specified."
      - determine null
      }
    - define numbers li@
    - define currenttotal 0
    - repeat <def[amount].sub[1].round>:
      - define numbers <def[numbers].include[<util.random.int[1].to[<def[total].sub[<def[currenttotal]>].sub[<def[amount].sub[<def[value]>]>].round>]>]>
      # new number = random int from 1 to ( specified total - current total - ( specified amount - current amount ) ) fml i hate math
      - define currenttotal <def[currenttotal].add[<def[numbers].last>]>
    - define numbers <def[numbers].include[<def[total].sub[<def[currenttotal]>]>]>
    - determine <def[numbers].random[<def[amount]>]>

DUL_rn:
# An internally faster version
  type: procedure
  debug: false
  DUL:
    name:
    - Random Numbers by Total
    author:
    - Anthony
    description:
    - returns the specified amount of random positive integer numbers that always add up to the specified total.
    usage:
    - <proc[DUL_rn].context[<amount>|<total>]>
    example:
    - <proc[DUL_rn].context[5|100]>
  definitions: a|t
  script:
    - define r li@
    - define s '%a%'
    - while <def[s].is[MORE].than[1]>:
      - define s '<def[s].sub[1].round>'
      - define n '<util.random.int[1].to[<def[t].sub[%s%].round>]>'
      - define t '<def[t].sub[%n%].round>'
      - define r '%r%%n%|'
    - define r '%r%%t%'
    - determine <def[r].random[%a%]>

#
